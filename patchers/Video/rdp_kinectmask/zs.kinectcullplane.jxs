<jittershader name="cullplane">	<description>	cull incoming depth matrix based on plane defined by three points	</description>	<param name="tex0" type="int" default="0" />	<param name="tex1" type="int" default="1" />	<param name="A" type="vec3" default="0. 0. 0." />	<param name="B" type="vec3" default="0. 0. 0." />	<param name="C" type="vec3" default="0. 0. 0." />	<param name="enable" type="int" default="0" />	<language name="glsl" version="1.0">		<bind param="tex0" program="fp" />		<bind param="tex1" program="fp" />		<bind param="A" program="fp" />		<bind param="B" program="fp" />		<bind param="C" program="fp" />		<bind param="enable" program="fp" />		<program name="vp" type="vertex"><![CDATA[// GLSL vertex program for doing a standard vertex transform and with texture coordinates. varying vec2 texcoord0;varying vec2 texcoord1;void main(){	// perform standard transform on vertex	gl_Position = ftransform();    	// transform texcoords	texcoord0 = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);	texcoord1 = vec2(gl_TextureMatrix[1] * gl_MultiTexCoord1);}]]>		</program>					<program name="fp" type="fragment"><![CDATA[// tex0 is 4 plane matrix of Kinect depth values (only r plane contains anything)// tex1 is 3 plane matrix as Cartesian transformation of depth valuesvarying vec2 texcoord0;varying vec2 texcoord1;uniform sampler2DRect tex0;uniform sampler2DRect tex1;// setup for plane pointsuniform vec3 A;uniform vec3 B;uniform vec3 C;uniform int enable;void main(){   	vec4 tex0_alt = vec4(texture2DRect(tex0, texcoord0).r, 0., 0., 0.);	if (enable == 1) {		vec3 ABxAC = cross(A-B, A-C);		vec3 PmA = texture2DRect(tex1, texcoord1).xyz - A;		vec3 Q = PmA * ABxAC;		float Qsum = Q.x + Q.y + Q.z;		float Qeval = 0.;		if (Qsum >= 0.) Qeval = 1.;				gl_FragColor = tex0_alt * vec4(Qeval);	}	else {		gl_FragColor = tex0_alt;	}	}]]>		</program>	</language></jittershader>